import tkinter as tk
from collections import deque
from copy import deepcopy

# This is the module where all the variables, classes, etc. that need to be shared across modules live.
# This is primarily for organizational reasons, though it also solves a few issues with circular imports.

# MISCELLANEOUS CLASSES
class Item:
    # f stands for function
    def f_default(self):
        """Default function as a fallback."""
        raise Exception('Card/token activated with default function.')

    def __init__(self, name='', image_file=None, function=f_default, prerun_function=None, item_type='', tags=()):
        self.name = name
        self.image_file = image_file
        self.function = function
        self.prerun_function = prerun_function  # A special function that runs before normal card activation starts
        self.item_type = item_type
        self.tags = tags

    def __repr__(self):
        return self.name


# MISCELLANEOUS FUNCTIONS
def pretty_print(self, holder, message):
    """Print an item's activation message with some standardized formatting and spacing."""
    target_length = 20  # The number of characters that will appear to the left of the message
    header_length = len(f'{holder.list.index(self)} {self.name}:')
    delta = target_length - header_length

    if delta > 0:
        spacer = ' ' * delta
    else:
        spacer = ' '

    print(f'{holder.list.index(self)} {self.name}:{spacer}{message}')


def item_factory(item_name):
    """Return a deepcopy of an item from card_dict/token_dict.

    Args:
        item_name: The desired item's key in card_dict/token_dict.

    Returns:
        A deepcopy of the item associated with the given key.
    """

    global card_dict
    global token_dict

    try:  # Note: This requires that we never have a card and token with the same internal name
        return deepcopy(card_dict[item_name])
    except KeyError:
        return deepcopy(token_dict[item_name])


# MISCELLANEOUS VARIABLES
root = tk.Tk()  # Define the main tkinter root here for better sharing

card_dict = {}  # Huge master dict of all the cards and their effects
token_dict = {}  # Huge master dict of all the tokens and their effects

do_slow_activation = None  # Becomes a tkinter IntVar at runtime
data = 0
score = 0

# CARD RARITY COEFFICIENTS
# These are used when opening booster packs to weight the card draw.
r_common = 10
r_uncommon = 5
r_rare = 3
r_legendary = 1
# Keep in mind that the "true" rarity of any type is equal to the rarity coefficient times the number of cards of that
# rarity. So if you don't make many legendary cards, they will be getting hit twice.

# CARDHOLDERS
class CardHolder:
    def __init__(self, max_length=-1, gui_frame=None):
        self.list = []  # In theory, would be better to have CardHolder inherit from list
        self.max_length = max_length
        self.active_index = -1

        self.gui_frame = gui_frame

# Set up our cardholders, which are just the places that cards go
deck = CardHolder()
active_row = CardHolder(max_length=6)
particle_row = CardHolder()
power_row = CardHolder(max_length=5)

# EVENT STACK STUFF
class StackEvent:
    # The things that go on the event stack. Generally, these are generated by cards/tokens when they are activated.
    def __init__(self, origin, function, f_args, tags=None):
        """
        Constructor.

        Args:
            origin: The object (usually a card/token) that the StackEvent came from.
            function: The function associated with the StackEvent. The main interpreter will execute this.
            f_args: Arguments to be passed to the function.
            tags: Currently unused.
        """

        self.origin = origin
        self.function = function
        self.f_args = f_args
        self.tags = tags

stack = deque([])  # Deque that contains all the StackEvents

# INTERPRETER STUFF
class Interpreter:
    # Interpreters are objects that process StackEvents. There is one main interpreter that executes card/token
    # functions and some number of additional interpreters that implement passive effects. Anything that needs to modify
    # a stack event or be triggered by a stack event is handled by Interpreters.
    def __init__(self, function, f_args=None):
        """
        Constructor.

        Args:
            function: The function the interpreter will execute. Must always take the event as the first argument.
            f_args: If the function needs any additional args, put them here. Not implemented right now.
        """
        self.function = function

# Deque that contains the interpreters. StackEvents are processed by each interpreter, starting with the top (most
# recently appended) and continuing down the deque until it hits the main interpreter that executes the StackEvent's
# function. This is always the final interpreter.
# Thus, the main interpreter must go on first. Append additional ones afterwards.
interpreters = deque([])

# Main interpreter, executes the function listed on the card/token
def f_main_interpreter(event):
    event.function(*event.f_args)
main_interpreter = Interpreter(f_main_interpreter)

interpreters.append(main_interpreter)
